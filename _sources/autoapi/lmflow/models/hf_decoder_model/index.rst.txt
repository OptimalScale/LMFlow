lmflow.models.hf_decoder_model
==============================

.. py:module:: lmflow.models.hf_decoder_model

.. autoapi-nested-parse::

   This is a class called HFDecoderModel which is a wrapper around transformers model and
   tokenizer classes. It has several methods such as __init__, tokenize, and train that are
   used for training and fine-tuning the model. The __init__ method takes in several arguments
   such as model_args which are used to load the pretrained
   model and tokenizer, and initialize the training settings.

   The tokenize method is used to tokenize the input text and return the input IDs and attention
   masks that can be fed to the model for training or inference.

   Overall, this class provides a convenient interface for loading and fine-tuning transformer
   models and can be used for various NLP tasks such as language modeling, text classification,
   and question answering.

   ..
       !! processed by numpydoc !!


Attributes
----------

.. autoapisummary::

   lmflow.models.hf_decoder_model.logger


Classes
-------

.. autoapisummary::

   lmflow.models.hf_decoder_model.HFDecoderModel


Module Contents
---------------

.. py:data:: logger

.. py:class:: HFDecoderModel(model_args, do_train=True, device='gpu', **kwargs)

   Bases: :py:obj:`lmflow.models.decoder_model.DecoderModel`, :py:obj:`lmflow.models.hf_model_mixin.HFModelMixin`, :py:obj:`lmflow.models.interfaces.tunable.Tunable`


   
   Initializes a HFDecoderModel instance.


   :Parameters:

       **model_args**
           Model arguments such as model name, path, revision, etc.

       **do_train** : bool, default True
           Determines whether to prepare the model for training, including distribtued env, model placement, quantization,
           lora, etc.

       **args** : Optional.
           Positional arguments.

       **kwargs** : Optional.
           Keyword arguments.














   ..
       !! processed by numpydoc !!

   .. py:method:: tokenize(dataset: lmflow.datasets.dataset.Dataset, add_special_tokens=True, *args, **kwargs) -> lmflow.datasets.dataset.Dataset

      
      Tokenize the full dataset.


      :Parameters:

          **dataset** : lmflow.datasets.Dataset.
              ..

          **args** : Optional.
              Positional arguments.

          **kwargs** : Optional.
              Keyword arguments.



      :Returns:

          tokenized_datasets
              The tokenized dataset, without any leading or trailing special
              tokens (normally they are Begin-Of-Sentence or End-Of-Sentence
              tokens).











      ..
          !! processed by numpydoc !!


   .. py:method:: encode(input: Union[str, list[str]], *args, **kwargs) -> Union[list[int], list[list[int]]]

      
      Perform encoding process of the tokenizer.


      :Parameters:

          **inputs** : str or list.
              The text sequence.

          **args** : Optional.
              Positional arguments.

          **kwargs** : Optional.
              Keyword arguments.



      :Returns:

          outputs
              if string input,return the tokenized inputs.
              "Hello,world!"-> [101, 7592, 1010, 2088, 102]
              if batch input,return {input_ids,attention_mask,token_type_ids}
              ["Hello,world!","Hello!"] ->
              {
                  'input_ids': tensor([[  101,  7592,  1010,  2088,   102],...),
                  'attention_mask': tensor([[1, 1, 1, 1, 1],[0,0,1,1,1]])
              }











      ..
          !! processed by numpydoc !!


   .. py:method:: decode(input, **kwargs) -> Union[str, list[str]]

      
      Perform decoding process of the tokenizer.


      :Parameters:

          **inputs** : list or tensor.
              The token sequence.

          **args** : Optional.
              Positional arguments.

          **kwargs** : Optional.
              Keyword arguments.



      :Returns:

          outputs
              The text decoded from the token inputs.
              if batch input,return the list of text
              [[101, 7592, 1010, 2088, 102],[101, 7592, 1010, 2088, 102]]-> ["Hello,world!","Hello,world!"
              if single input,return the text
              [101, 7592, 1010, 2088, 102]-> "Hello,world!"











      ..
          !! processed by numpydoc !!


   .. py:method:: inference(inputs: Union[str, list[str], torch.Tensor, lmflow.utils.protocol.DataProto], sampling_params: Optional[Union[dict, vllm.SamplingParams]] = None, return_logprob: bool = False, release_gpu: bool = False, inference_engine: Literal['huggingface', 'vllm', 'sglang'] = 'huggingface', gpu_memory_utilization: Optional[float] = None, tensor_parallel_size: Optional[int] = None, enable_deterministic_inference: bool = False, attention_backend: Optional[str] = None, **kwargs) -> Union[list[lmflow.utils.data_utils.VLLMInferenceResultWithInput] | lmflow.utils.protocol.DataProto]

      
      Perform generation process of the model.


      :Parameters:

          **inputs** : Union[str, list[str], torch.Tensor, DataProto]
              The sequence used as a prompt for the generation or as model inputs to the model.
              When the inference engine is "vllm", this should be a string or a list of strings.
              When the inference engine is "huggingface", this should be a tensor.
              When the inference engine is "sglang", this should be a DataProto.

          **sampling_params** : Optional[Union[dict, "SamplingParams"]], optional
              The sampling parameters to use, by default None.

          **return_logprob** : bool, optional
              Whether to return log probability during inference, by default False.

          **release_gpu** : bool, optional
              Whether to release the GPU resource after inference, by default False.

          **inference_engine** : Literal["huggingface", "vllm", "sglang"], optional
              The inference engine to use, by default "huggingface".

          **gpu_memory_utilization** : float, optional
              The GPU memory utilization to use, by default None.

          **tensor_parallel_size** : int, optional
              The tensor parallel size to use, by default None.

          **enable_deterministic_inference** : bool, optional
              Whether to enable deterministic inference, by default False.

          **attention_backend** : Optional[str], optional
              The attention backend to use, by default None.



      :Returns:

          outputs
              The generated sequence output











      ..
          !! processed by numpydoc !!


   .. py:method:: __inference(inputs, *args, **kwargs)

      
      Perform generation process of the model.


      :Parameters:

          **inputs**
              The **tokenized** sequence used as a prompt for the generation or as model inputs to the model.

          **args** : Optional.
              Positional arguments.

          **kwargs** : Optional.
              Keyword arguments.



      :Returns:

          outputs
              The generated sequence output











      ..
          !! processed by numpydoc !!


   .. py:method:: __vllm_inference(inputs: list[str], sampling_params: Optional[vllm.SamplingParams] = None) -> list[lmflow.utils.data_utils.VLLMInferenceResultWithInput]

      
      Perform VLLM inference process of the model.


      :Parameters:

          **inputs** : list[str]
              Prompt(s), string or a list of strings.

          **sampling_params** : Optional[SamplingParams], optional
              vllm SamplingParams object, by default None.



      :Returns:

          list[VLLMInferenceResultWithInput]
              Return a list of VLLMInferenceResultWithInput, where each
              element contains the input prompt and the corresponding output.
              
              When `sampling_params.detokenize = True`, the output would be a list of strings,
              contains sampling_params.n samples for the corresponding prompt.
              
              When `sampling_params.detokenize = False`, return a list of list of ints
              (token ids, no decoding after generation).











      ..
          !! processed by numpydoc !!


   .. py:method:: __sglang_inference(inputs: lmflow.utils.protocol.DataProto, return_logprob: bool = False) -> lmflow.utils.protocol.DataProto

      
      Perform SGLang inference process of the model.
















      ..
          !! processed by numpydoc !!


   .. py:method:: prepare_inputs_for_inference(dataset: lmflow.datasets.dataset.Dataset, apply_chat_template: bool = True, inference_engine: Literal['huggingface', 'vllm', 'sglang'] = 'huggingface', enable_distributed_inference: bool = False, sampling_params: Optional[dict] = None) -> Union[list[str], ray.data.Dataset, lmflow.utils.protocol.DataProto]


   .. py:method:: merge_lora_weights()


   .. py:method:: get_peft_without_qlora()


   .. py:method:: save(dir, save_full_model=False, *args, **kwargs)

      
      Perform generation process of the model.


      :Parameters:

          **dir**
              The directory to save model and tokenizer

          **save_full_model** : Optional.
              Whether to save full model.

          **kwargs** : Optional.
              Keyword arguments.



      :Returns:

          outputs
              The generated sequence output











      ..
          !! processed by numpydoc !!


